@using TN.Client.Services.Shared.Interfaces;
@using TN.Client.Services.Shared.Models;
@using TN.Client.Services.Shared.Entities;

<CascadingValue Value="this">
    <nav id="side-menu" class="navbar">
        <div class="navbar-wrapper">
            <TNNavTenant />
            <div class="navbar-content">
                <ul class="inner-navbar">
                    <TNNavSeparator />
                    @foreach (var menuItem in MenuItems.OrderBy(q => q.Order))
                    {
                        if (menuItem.SubMenus.Any())
                        {
                            <TNNavMenuItem Url="@menuItem.Url" Icon="@menuItem.Icon" Text="@menuItem.Text">
                                @foreach (var subMenuItem in menuItem.SubMenus.OrderBy(q => q.Order))
                                {
                                    <TNNavMenuItem Url="@subMenuItem.Url" Text="@subMenuItem.Text" />
                                }
                            </TNNavMenuItem>
                        }
                        else
                        {
                            <TNNavMenuItem Url="@menuItem.Url" Icon="@menuItem.Icon" Text="@menuItem.Text" />
                        }
                    }
                </ul>

                <ul class="inner-navbar mavbar-bottom-items">
                    @if (MenuNavbarBottom != null && MenuNavbarBottom.Count > 0)
                    {
                        @foreach (var menuItem in MenuNavbarBottom.OrderBy(q => q.Order))
                        {
                            <TNNavMenuItem Url="@menuItem.Url" Icon="@menuItem.Icon" Text="@menuItem.Text" />
                        }
                    }
                </ul>
            </div>
        </div>
    </nav>
</CascadingValue>

@code {
    [Parameter] public List<MenuEntity> MenuNavbarBottom { get; set; }

    [Inject] protected IJSRuntime JSRuntime { get; set; }
    [Inject] protected NavigationManager NavigationManager { get; set; }
    [Inject] protected IMenuService MenuService { get; set; }

    private List<TNNavMenuItem> NavMenuItems = new List<TNNavMenuItem>();
    private List<MenuEntity> MenuItems = new List<MenuEntity>();
    private bool ShowBottomNavbarData = false;

    protected override async Task OnInitializedAsync()
    {
        var response = await MenuService.GetMenus(1, MenuType.Left);
        MenuItems = response.Menus;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            ShowBottomNavbarData = !await JSRuntime.IsMobile();
            this.StateHasChanged();
        }
    }


    internal void AddMenuItem(TNNavMenuItem navMenuItem)
    {
        NavMenuItems.Add(navMenuItem);
    }

    public Task OpenSubMenu(TNNavMenuItem navMenuItem)
    {
        foreach (var item in NavMenuItems.Where(q => !q.Equals(navMenuItem) && !q.NavSubMenuItems.Any(p => p.Equals(navMenuItem))))
            item.SubMenuOpened = false;

        navMenuItem.SubMenuOpened = !navMenuItem.SubMenuOpened;

        this.StateHasChanged();

        return Task.CompletedTask;
    }

    public async Task SelectMenuItem(TNNavMenuItem navMenuItem)
    {
        foreach (var item in NavMenuItems.Where(q => !q.Equals(navMenuItem)))
            item.Selected = false;

        navMenuItem.Selected = true;

        await JSRuntime.ToggleMenu();

        RedirectToUrl(navMenuItem.Url);

        this.StateHasChanged();
    }

    private void RedirectToUrl(string url)
    {
        NavigationManager.NavigateTo(url);
    }
}